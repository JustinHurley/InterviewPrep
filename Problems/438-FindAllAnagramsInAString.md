---
tags:
  - sliding_window
  - dictionary
  - string
  - medium
---

### 438. Find All Anagrams in a String
Link: [here](https://leetcode.com/problems/find-all-anagrams-in-a-string/)

We want to find out if one of the strings is an anagram of the other. This makes the problem partially easier because we now are working with a fixed window of length `len(p)`. This means we can just move through the array with a sliding window, keeping track of the chars in the current window to know if we have an anagram or not.

The general approach is to make a dict from `p` where chars are keys and the value is the count of each char in the string. Using this dictionary we compare it with a different dictionary that is generated by keeping track of chars in the window also via a dictionary.

We first start by adding the chars between `s[0]` and `s[len(p)]` which fills our "starting window." Then we actually iterate through the string, starting at `len[p]` as we have already added chars before that. As we move through the string, we increase the count of chars in the dict when we see them with the leading index (and if they are in `p`) and decrease the count of chars with the back index as it is no longer in the window.

To save some time and space, you can just check to see if the current char in `s` is in `p` before actually adding it to the `s` dict. This saves time adding chars that will never be part of an anagram.

It is important to note that for this problem, you will need to do an extra check outside of the loop as you can either check before or after you update the dicts. If you check before, you miss out on the last iteration, and if you check after, you miss out on the first iteration, so just keep in mind when you are dealing with a situation where an iteration misses a check and must be done outside the loop.

Solution
```
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        # Edge cases
        if len(p) > len(s) or len(p) == 0 or len(s) == 0:
            return []
        
        ans = []
        pDict = {}
        # Add char count to pDict
        for c in p:
            pDict[c] = pDict.get(c,0)+1
        # Set a slow pointer to keep track of start of anagram 
        back = 0
        sDict = {}
        # Need to populate sDict with first few values that are also in p
        for i in range(len(p)):
            if s[i] in pDict:
                sDict[s[i]] = sDict.get(s[i],0)+1
            
        # Move through s adding and removing as you go
        for i in range(len(p),len(s)):
            # Are they equal
            if sDict == pDict:
                ans.append(back)
            # Check if curr char in p
            if s[i] in pDict:
                sDict[s[i]] = sDict.get(s[i],0) + 1
            # Remove back char if applicable
            if s[back] in pDict:
                sDict[s[back]] -= 1
            # Move back up
            back += 1
        
        # Need to do a final check as we check pre iteration
        if sDict == pDict:
            ans.append(back)
        return ans
```

